```{r}
load("./strokeStudy.RData")
```

```{r}
library(ggplot2)
library(dplyr)
library(nlme)
library(broom)
library(knitr)
library(stringr)
library(tidyverse)
library(janitor)
library(naniar)
library(mice)
```

# EDA
```{r}
x <- x %>% clean_names()%>%
  rename(emsvscar = em_svs_car)

x$race2[x$race2 == "Missing"] <- NA
x$race2 <- factor(x$race2) 
x$site_id <- factor(x$site_id)

str(x)
```

missingness per variable
```{r}
na_table <- x %>% 
  summarise(across(everything(), ~ sum(is.na(.)))) %>% 
  pivot_longer(everything(),
               names_to = "variable",
               values_to = "n_missing") %>%
  arrange(desc(n_missing))


```

missingness aggregated by site
```{r}
x %>%
  group_by(site_id) %>%
  summarise(across(everything(), ~ mean(is.na(.)))) %>%
  pivot_longer(-site_id, names_to = "variable", values_to = "prop_missing") %>%
  ggplot(aes(x = variable, y = site_id, fill = prop_missing)) +
  geom_tile() +
  scale_fill_viridis_c() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Missingness by Site")
```

```{r}
x %>%
  ggplot(aes(x = home_or_rehab, y = age, fill = home_or_rehab)) +
  geom_boxplot() +
  labs(title = "Age Differences by Outcome")
```

```{r}
x %>% 
  ggplot(aes(x = gender, fill = home_or_rehab)) +
  geom_bar(position = "fill") +
  labs(y = "Proportion", 
       title = "Outcome by Gender")

```

```{r}
x %>% 
  ggplot(aes(x = race2, fill = home_or_rehab)) +
  geom_bar(position = "fill") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y = "Proportion", 
       title = "Outcome by Race")
```

```{r}
x <- x %>%
  mutate(ems_label = case_when(
    emsvscar == 1 ~ "EMS Arrival",
    emsvscar == 0 ~ "Car Arrival",
    TRUE ~ "Missing"
  ))
x %>% 
  ggplot(aes(x = ems_label, fill = home_or_rehab)) +
  geom_bar(position = "dodge") +
  labs(title = "Outcome by Arrival Method",
       x = "Arrival Method",
       y = "Count",
       fill = "Good Outcome") +
  scale_fill_manual(values = c("FALSE" = "tomato", "TRUE" = "steelblue"))
```

missingness by quarter
```{r}
x %>%
  group_by(time2) %>%
  summarise(across(everything(), ~ mean(is.na(.)))) %>%
  pivot_longer(-time2, names_to = "variable", values_to = "prop_missing") %>%
  ggplot(aes(variable, time2, fill = prop_missing)) +
  geom_tile() +
  scale_fill_viridis_c() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Missingness by Quarter")
```

missingness correlation plot
```{r}
vis_miss(x)
```

age missingness by site x quarter

```{r}
x %>%
  mutate(age_missing = is.na(age)) %>%
  group_by(site_id, time2) %>%
  summarise(prop_age_missing = mean(age_missing), .groups = "drop") %>%
  ggplot(aes(x = time2, y = site_id, fill = prop_age_missing)) +
  geom_tile(color = "white") +
  scale_fill_viridis_c(labels = scales::percent_format(accuracy = 1)) +
  labs(
    title = "Share of Records Missing Age by Site and Quarter",
    fill = "Percent\nMissing"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Can clearly see that this is not MCAR; its MAR.

# Missing data + Frequentist model

use predictive mean matching by drawing 20 multiply imputed data sets



```{r}
impute_vars <- x %>%
   dplyr::select(
    home_or_rehab, age, gender, race2, emsvscar, pre_hosp_notify,
    had_tpa, had_thrombectomy, tpa_complic, thr_complic,
    site_id, time2
  )

meth <- make.method(impute_vars)
meth["age"] <- "pmm"

pred <- make.predictorMatrix(impute_vars)
pred["age", ] <- 0
pred["age", c("gender", "race2", "emsvscar", "pre_hosp_notify",
              "had_tpa", "had_thrombectomy", "tpa_complic",
              "thr_complic", "site_id", "time2", "home_or_rehab")] <- 1

set.seed(2025)
imp <- mice(
  impute_vars,
  m = 20,
  maxit = 20,
  method = meth,
  predictorMatrix = pred,
  seed = 2025,
  printFlag = FALSE
)

imp
```
constructs 20 predictive-mean-matching imputations for Age using the specified covariates

```{r}
fit1_mi <- with(
  imp,
  glm(
    home_or_rehab ~ age + gender + race2 + emsvscar + pre_hosp_notify +
      had_tpa + had_thrombectomy + tpa_complic + thr_complic + time2,
    family = binomial
  )
)

pool(fit1_mi) %>% summary(conf.int = TRUE, exponentiate = TRUE)
```
fits the logistic model within each imputed dataset and pools odds ratios that respect imputation uncertainty.
# Frequentist model diagnostics

1. first imputed dataset
```{r}
comp1 <- complete(imp, 1)  # first imputed dataset

fit_fixed <- glm(
  home_or_rehab ~ age + gender + race2 + emsvscar + pre_hosp_notify +
    had_tpa + had_thrombectomy + tpa_complic + thr_complic + time2,
  data = comp1,
  family = binomial
)
comp1$pred <- predict(fit_fixed, type="response")

```

```{r}
library(lme4)

fit_mixed <- glmer(
  home_or_rehab ~ age + gender + race2 + emsvscar + pre_hosp_notify +
    had_tpa + had_thrombectomy + tpa_complic + thr_complic + time2 +
    (1 | site_id),
  data   = comp1,
  family = binomial
)
```
random effect for site id is extremely small (variance close to 0)
```{r}
pearson_res <- residuals(fit_fixed, type = "pearson")

# Overdispersion ratio
overdisp_fixed <- sum(pearson_res^2) / df.residual(fit_fixed)
overdisp_fixed
pearson_res_mixed <- residuals(fit_mixed, type = "pearson")
overdisp_mixed <- sum(pearson_res_mixed^2) / df.residual(fit_mixed)
overdisp_mixed
```
≈ 1 → no overdispersion in both fixed & mixed model
-> adding site effect doesnt reduce dispersion


2. all imputed datasets
```{r}
cal_list <- lapply(1:imp$m, function(k) {
  dat_k <- complete(imp, k)

  fit_k <- glm(
    home_or_rehab ~ age + gender + race2 + emsvscar + pre_hosp_notify +
      had_tpa + had_thrombectomy + tpa_complic + thr_complic + time2,
    data = dat_k,
    family = binomial
  )

  dat_k$pred <- predict(fit_k, type = "response")

  dat_k %>%
    mutate(
      bin = ntile(pred, 10),
      imp = k
    ) %>%
    group_by(imp, bin) %>%
    summarise(
      mean_pred = mean(pred),
      obs_rate  = mean(home_or_rehab),
      .groups   = "drop"
    )
})

cal_all <- bind_rows(cal_list)
```


# calibration plot
```{r}
library(arm)

cal <- comp1 %>%
  mutate(bin = ntile(pred, 10)) %>%
  group_by(bin) %>%
  summarise(
    mean_pred = mean(pred),
    obs_rate = mean(home_or_rehab)
  )

ggplot(cal, aes(mean_pred, obs_rate)) +
  geom_point(size=3) +
  geom_abline(slope=1, intercept=0, linetype="dashed", color="red") +
  labs(title="Calibration Plot",
       x="Mean Predicted Probability",
       y="Observed Proportion")
```
```{r}
ggplot(cal_all, aes(x = mean_pred, y = obs_rate)) +
  geom_point(size = 1.8) +
  geom_abline(slope = 1, intercept = 0,
              linetype = "dashed", color = "red") +
  coord_equal(xlim = c(0,1), ylim = c(0,1)) +
  facet_wrap(~ imp) +
  labs(
    title = "Calibration Plots Across Imputations",
    x = "Mean Predicted Probability",
    y = "Observed Proportion"
  )
```

# ROC curve
```{r}
library(pROC)
roc_obj <- roc(comp1$home_or_rehab, comp1$pred)

auc_value <- auc(roc_obj)


plot(1 - roc_obj$specificities,
     roc_obj$sensitivities,
     type = "l",
     col = "steelblue",
     xlab = "1 – Specificity (False Positive Rate)",
     ylab = "Sensitivity",
     main = "ROC Curve")

abline(0, 1, lty = 2, col = "gray")
text(
  x = 0.6, y = 0.1,
  labels = paste("AUC =", round(auc_value, 3)),
  cex = 1.3
)
```
```{r}
roc_list <- lapply(1:20, function(k) {
  dat_k <- complete(imp, k)

  fit_k <- glm(
    home_or_rehab ~ age + gender + race2 + emsvscar + pre_hosp_notify +
      had_tpa + had_thrombectomy + tpa_complic + thr_complic + time2,
    data = dat_k,
    family = binomial
  )

  pred_k <- predict(fit_k, type = "response")

  roc(dat_k$home_or_rehab, pred_k)
})

# Turn ROC curves into a data frame
roc_df <- lapply(seq_along(roc_list), function(k) {
  data.frame(
    imp = k,
    fpr = 1 - roc_list[[k]]$specificities,  # 1 - specificity
    tpr = roc_list[[k]]$sensitivities       # sensitivity
  )
}) %>% bind_rows()

# AUC per imputation (for optional labels)
auc_values <- sapply(roc_list, auc)
auc_df <- data.frame(
  imp = 1:20,
  auc = auc_values
)

# Faceted ROC plots
ggplot(roc_df, aes(x = fpr, y = tpr)) +
  geom_line(color = "steelblue") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  facet_wrap(~ imp) +
  labs(
    title = "ROC Curves Across Imputations",
    x = "1 – Specificity (False Positive Rate)",
    y = "Sensitivity"
  ) +
  # Optional: add AUC text inside each facet
  geom_text(
    data = auc_df,
    aes(x = 0.7, y = 0.1,
        label = paste0("AUC = ", round(auc, 3))),
    inherit.aes = FALSE,
    size = 3
  )
```



# which variables were predictive of missingness
```{r}
x$miss_age <- ifelse(is.na(x$age), 1, 0)
find_predictors_of_missingness <- function(var) {
  
  # 1. Create missingness indicator
  miss_indicator <- as.numeric(is.na(x[[var]]))
  
  # 2. Build dataset with predictors (drop the variable being tested)
  predictors <- x[, setdiff(names(x), var), drop = FALSE]
  
  # 3. Combine into one dataframe
  data_miss <- data.frame(miss = miss_indicator, predictors)
  
  # 4. Fit logistic regression
  fit <- glm(miss ~ ., data = data_miss, family = binomial)
  
  return(summary(fit))
}

find_predictors_of_missingness("age")


```
indicates perfect separation (complete separation)
missingness mechanism is

Not random. but structural, driven by site and quarter






# Bayesian model
```{r}
for (i in 1:N) {
  race[i] ~ dcat(pi_race[site_id[i], 1:3])
}

for (j in 1:9) {
  pi_race[j, 1:3] ~ ddirch(alpha[])
}
alpha <- c(1/2, 1/2, 1/2) # jeffreys non-informative prior


```

