```{r}
load("./strokeStudy.RData")
```

```{r}
library(ggplot2)
library(dplyr)
library(nlme)
library(broom)
library(knitr)
library(stringr)
library(tidyverse)
library(janitor)
library(naniar)
library(mice)
```

# EDA
```{r}
x <- x %>%
  clean_names() %>%
  rename(emsvscar = em_svs_car) %>%
  mutate(
    race2 = na_if(race2, "Missing"),
    race2 = factor(race2),
    site_id = factor(site_id),
    home_num = as.integer(home_or_rehab),
    notify_num = case_when(
      pre_hosp_notify == "Yes" ~ 1,
      pre_hosp_notify == "No" ~ 0,
      TRUE ~ NA_real_
    ),
    transport_num = case_when(
      emsvscar == 1 ~ 1,
      emsvscar == 0 ~ 0,
      TRUE ~ NA_real_
    ),
    gender_num = if_else(gender == "Female", 1, 0)
  )

str(x)
```

missingness per variable
```{r}
na_table <- x %>% 
  summarise(across(everything(), ~ sum(is.na(.)))) %>% 
  pivot_longer(everything(),
               names_to = "variable",
               values_to = "n_missing") %>%
  arrange(desc(n_missing))


```

missingness aggregated by site
```{r}
x %>%
  group_by(site_id) %>%
  summarise(across(everything(), ~ mean(is.na(.)))) %>%
  pivot_longer(-site_id, names_to = "variable", values_to = "prop_missing") %>%
  ggplot(aes(x = variable, y = site_id, fill = prop_missing)) +
  geom_tile() +
  scale_fill_viridis_c() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Missingness by Site")
```

```{r}
x %>%
  ggplot(aes(x = home_or_rehab, y = age, fill = home_or_rehab)) +
  geom_boxplot() +
  labs(title = "Age Differences by Outcome")
```

```{r}
x %>% 
  ggplot(aes(x = gender, fill = home_or_rehab)) +
  geom_bar(position = "fill") +
  labs(y = "Proportion", 
       title = "Outcome by Gender")

```

```{r}
x %>% 
  ggplot(aes(x = race2, fill = home_or_rehab)) +
  geom_bar(position = "fill") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y = "Proportion", 
       title = "Outcome by Race")
```

```{r}
x <- x %>%
  mutate(ems_label = case_when(
    emsvscar == 1 ~ "EMS Arrival",
    emsvscar == 0 ~ "Car Arrival",
    TRUE ~ "Missing"
  ))
x %>% 
  ggplot(aes(x = ems_label, fill = home_or_rehab)) +
  geom_bar(position = "dodge") +
  labs(title = "Outcome by Arrival Method",
       x = "Arrival Method",
       y = "Count",
       fill = "Good Outcome") +
  scale_fill_manual(values = c("FALSE" = "tomato", "TRUE" = "steelblue"))
```

missingness by quarter
```{r}
x %>%
  group_by(time2) %>%
  summarise(across(everything(), ~ mean(is.na(.)))) %>%
  pivot_longer(-time2, names_to = "variable", values_to = "prop_missing") %>%
  ggplot(aes(variable, time2, fill = prop_missing)) +
  geom_tile() +
  scale_fill_viridis_c() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Missingness by Quarter")
```

missingness correlation plot
```{r}
vis_miss(x)
```

age missingness by site x quarter

```{r}
x %>%
  mutate(age_missing = is.na(age)) %>%
  group_by(site_id, time2) %>%
  summarise(prop_age_missing = mean(age_missing), .groups = "drop") %>%
  ggplot(aes(x = time2, y = site_id, fill = prop_age_missing)) +
  geom_tile(color = "white") +
  scale_fill_viridis_c(labels = scales::percent_format(accuracy = 1)) +
  labs(
    title = "Share of Records Missing Age by Site and Quarter",
    fill = "Percent\nMissing"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Can clearly see that this is not MCAR; its MAR.

# Missing data + Frequentist model

use predictive mean matching by drawing 20 multiply imputed data sets



```{r}
impute_vars <- x %>%
   dplyr::select(
    home_or_rehab, age, gender, race2, emsvscar, pre_hosp_notify,
    had_tpa, had_thrombectomy, tpa_complic, thr_complic,
    site_id, time2
  )

meth <- make.method(impute_vars)
meth["age"] <- "pmm"

pred <- make.predictorMatrix(impute_vars)
pred["age", ] <- 0
pred["age", c("gender", "race2", "emsvscar", "pre_hosp_notify",
              "had_tpa", "had_thrombectomy", "tpa_complic",
              "thr_complic", "site_id", "time2", "home_or_rehab")] <- 1

set.seed(2025)
imp <- mice(
  impute_vars,
  m = 20,
  maxit = 20,
  method = meth,
  predictorMatrix = pred,
  seed = 2025,
  printFlag = FALSE
)

imp
```
constructs 20 predictive-mean-matching imputations for Age using the specified covariates

```{r}
fit1_mi <- with(
  imp,
  glm(
    home_or_rehab ~ age + gender + race2 + emsvscar + pre_hosp_notify +
      had_tpa + had_thrombectomy + tpa_complic + thr_complic + time2,
    family = binomial
  )
)

pool(fit1_mi) %>% summary(conf.int = TRUE, exponentiate = TRUE)
```
fits the logistic model within each imputed dataset and pools odds ratios that respect imputation uncertainty.
# Frequentist model diagnostics

1. first imputed dataset
```{r}
comp1 <- complete(imp, 1)  # first imputed dataset

fit_fixed <- glm(
  home_or_rehab ~ age + gender + race2 + emsvscar + pre_hosp_notify +
    had_tpa + had_thrombectomy + tpa_complic + thr_complic + time2,
  data = comp1,
  family = binomial
)
comp1$pred <- predict(fit_fixed, type="response")

```

```{r}
library(lme4)

fit_mixed <- glmer(
  home_or_rehab ~ age + gender + race2 + emsvscar + pre_hosp_notify +
    had_tpa + had_thrombectomy + tpa_complic + thr_complic + time2 +
    (1 | site_id),
  data   = comp1,
  family = binomial
)
```
random effect for site id is extremely small (variance close to 0)
```{r}
pearson_res <- residuals(fit_fixed, type = "pearson")

# Overdispersion ratio
overdisp_fixed <- sum(pearson_res^2) / df.residual(fit_fixed)
overdisp_fixed
pearson_res_mixed <- residuals(fit_mixed, type = "pearson")
overdisp_mixed <- sum(pearson_res_mixed^2) / df.residual(fit_mixed)
overdisp_mixed
```
≈ 1 → no overdispersion in both fixed & mixed model
-> adding site effect doesnt reduce dispersion


2. all imputed datasets
```{r}
cal_list <- lapply(1:imp$m, function(k) {
  dat_k <- complete(imp, k)

  fit_k <- glm(
    home_or_rehab ~ age + gender + race2 + emsvscar + pre_hosp_notify +
      had_tpa + had_thrombectomy + tpa_complic + thr_complic + time2,
    data = dat_k,
    family = binomial
  )

  dat_k$pred <- predict(fit_k, type = "response")

  dat_k %>%
    mutate(
      bin = ntile(pred, 10),
      imp = k
    ) %>%
    group_by(imp, bin) %>%
    summarise(
      mean_pred = mean(pred),
      obs_rate  = mean(home_or_rehab),
      .groups   = "drop"
    )
})

cal_all <- bind_rows(cal_list)
```


# calibration plot
```{r}
library(arm)

cal <- comp1 %>%
  mutate(bin = ntile(pred, 10)) %>%
  group_by(bin) %>%
  summarise(
    mean_pred = mean(pred),
    obs_rate = mean(home_or_rehab)
  )

ggplot(cal, aes(mean_pred, obs_rate)) +
  geom_point(size=3) +
  geom_abline(slope=1, intercept=0, linetype="dashed", color="red") +
  labs(title="Calibration Plot",
       x="Mean Predicted Probability",
       y="Observed Proportion")
```
```{r}
ggplot(cal_all, aes(x = mean_pred, y = obs_rate)) +
  geom_point(size = 1.8) +
  geom_abline(slope = 1, intercept = 0,
              linetype = "dashed", color = "red") +
  coord_equal(xlim = c(0,1), ylim = c(0,1)) +
  facet_wrap(~ imp) +
  labs(
    title = "Calibration Plots Across Imputations",
    x = "Mean Predicted Probability",
    y = "Observed Proportion"
  )
```

# ROC curve
```{r}
library(pROC)
roc_obj <- roc(comp1$home_or_rehab, comp1$pred)

auc_value <- auc(roc_obj)


plot(1 - roc_obj$specificities,
     roc_obj$sensitivities,
     type = "l",
     col = "steelblue",
     xlab = "1 – Specificity (False Positive Rate)",
     ylab = "Sensitivity",
     main = "ROC Curve")

abline(0, 1, lty = 2, col = "gray")
text(
  x = 0.6, y = 0.1,
  labels = paste("AUC =", round(auc_value, 3)),
  cex = 1.3
)
```
```{r}
roc_list <- lapply(1:20, function(k) {
  dat_k <- complete(imp, k)

  fit_k <- glm(
    home_or_rehab ~ age + gender + race2 + emsvscar + pre_hosp_notify +
      had_tpa + had_thrombectomy + tpa_complic + thr_complic + time2,
    data = dat_k,
    family = binomial
  )

  pred_k <- predict(fit_k, type = "response")

  roc(dat_k$home_or_rehab, pred_k)
})

# Turn ROC curves into a data frame
roc_df <- lapply(seq_along(roc_list), function(k) {
  data.frame(
    imp = k,
    fpr = 1 - roc_list[[k]]$specificities,  # 1 - specificity
    tpr = roc_list[[k]]$sensitivities       # sensitivity
  )
}) %>% bind_rows()

# AUC per imputation (for optional labels)
auc_values <- sapply(roc_list, auc)
auc_df <- data.frame(
  imp = 1:20,
  auc = auc_values
)

# Faceted ROC plots
ggplot(roc_df, aes(x = fpr, y = tpr)) +
  geom_line(color = "steelblue") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  facet_wrap(~ imp) +
  labs(
    title = "ROC Curves Across Imputations",
    x = "1 – Specificity (False Positive Rate)",
    y = "Sensitivity"
  ) +
  # Optional: add AUC text inside each facet
  geom_text(
    data = auc_df,
    aes(x = 0.7, y = 0.1,
        label = paste0("AUC = ", round(auc, 3))),
    inherit.aes = FALSE,
    size = 3
  )
```



# which variables were predictive of missingness
```{r}
x$miss_age <- ifelse(is.na(x$age), 1, 0)
find_predictors_of_missingness <- function(var) {
  
  # 1. Create missingness indicator
  miss_indicator <- as.numeric(is.na(x[[var]]))
  
  # 2. Build dataset with predictors (drop the variable being tested)
  predictors <- x[, setdiff(names(x), var), drop = FALSE]
  
  # 3. Combine into one dataframe
  data_miss <- data.frame(miss = miss_indicator, predictors)
  
  # 4. Fit logistic regression
  fit <- glm(miss ~ ., data = data_miss, family = binomial)
  
  return(summary(fit))
}

find_predictors_of_missingness("age")


```
indicates perfect separation (complete separation)
missingness mechanism is

Not random. but structural, driven by site and quarter






# Bayesian model

```{r}
model_string <- "
model {

  ################################################
  # 0. OUTCOME MODEL: home_or_rehab
  ################################################

  for (i in 1:N) {
    # Binary outcome
    home[i] ~ dbern(p[i])

    # Logistic mixed model
    logit(p[i]) <-
        beta0 +
        beta_age   * age[i] +
        beta_gender * gender[i] +          # assume 0/1
        beta_ems   * transport[i] +        # EMS vs car
        beta_not   * notify[i] +
        beta_tpa   * had_tpa[i] +
        beta_thr   * had_thromb[i] +
        beta_tpaC  * tpa_comp[i] +
        beta_thrC  * thr_comp[i] +
        beta_time[ time[i] ] +
        beta_race[race[i]] +               # race coded 1..nRace
        u_site_out[ site[i] ]              # site random effect
  }

  # Priors for outcome fixed effects
  beta0       ~ dnorm(0, 1.0E-4)
  beta_age    ~ dnorm(0, 1.0E-4)
  beta_gender ~ dnorm(0, 1.0E-4)
  beta_ems    ~ dnorm(0, 1.0E-4)
  beta_not    ~ dnorm(0, 1.0E-4)
  beta_tpa    ~ dnorm(0, 1.0E-4)
  beta_thr    ~ dnorm(0, 1.0E-4)
  beta_tpaC   ~ dnorm(0, 1.0E-4)
  beta_thrC   ~ dnorm(0, 1.0E-4)

  # Time (quarter) effects
  for (t in 1:nTime) {
    beta_time[t] ~ dnorm(0, 1.0E-4)
  }

  # Race effects, last category as reference
  for (r in 1:(nRace-1)) {
    beta_race[r] ~ dnorm(0, 1.0E-4)
  }
  beta_race[nRace] <- 0

  # Site random intercepts for outcome
  for (s in 1:nSite) {
    u_site_out[s] ~ dnorm(0, tau_site_out)
  }
  tau_site_out <- pow(sigma_site_out, -2)
  sigma_site_out ~ dunif(0, 2)


  ################################################
  # 1. AGE MODEL: age | site, time (FIRST in ordering)
  ################################################

  for (i in 1:N) {
    age[i] ~ dnorm(mu_age[i], tau_age)
    mu_age[i] <-
        alpha0 +
        alpha_time[ time[i] ] +
        alpha_gender * gender[i] +    # optional, you can drop if you want simpler
        u_site_age[ site[i] ]
  }

  alpha0       ~ dnorm(0, 1.0E-4)
  alpha_gender ~ dnorm(0, 1.0E-4)

  for (t in 1:nTime) {
    alpha_time[t] ~ dnorm(0, 1.0E-4)
  }

  for (s in 1:nSite) {
    u_site_age[s] ~ dnorm(0, tau_site_age)
  }

  tau_age        <- pow(sigma_age, -2)
  sigma_age      ~ dunif(0, 50)      # age in years
  tau_site_age   <- pow(sigma_site_age, -2)
  sigma_site_age ~ dunif(0, 20)


  ################################################
  # 2. NOTIFY MODEL: notify | age, site, time (SECOND)
  ################################################

  for (i in 1:N) {
    notify[i] ~ dbern(pi_not[i])

    logit(pi_not[i]) <-
        delta0 +
        delta_age   * age[i] +
        delta_time[ time[i] ] +
        u_site_not[ site[i] ]
  }

  delta0    ~ dnorm(0, 1.0E-4)
  delta_age ~ dnorm(0, 1.0E-4)

  for (t in 1:nTime) {
    delta_time[t] ~ dnorm(0, 1.0E-4)
  }

  for (s in 1:nSite) {
    u_site_not[s] ~ dnorm(0, tau_site_not)
  }
  tau_site_not <- pow(sigma_site_not, -2)
  sigma_site_not ~ dunif(0, 2)


  ################################################
  # 3. TRANSPORT MODEL: transport | age, notify, site, time (THIRD)
  ################################################

  for (i in 1:N) {
    transport[i] ~ dbern(pi_tr[i])

    logit(pi_tr[i]) <-
        gamma0 +
        gamma_age   * age[i] +
        gamma_not   * notify[i] +
        gamma_time[ time[i] ] +
        u_site_tr[ site[i] ]
  }

  gamma0    ~ dnorm(0, 1.0E-4)
  gamma_age ~ dnorm(0, 1.0E-4)
  gamma_not ~ dnorm(0, 1.0E-4)

  for (t in 1:nTime) {
    gamma_time[t] ~ dnorm(0, 1.0E-4)
  }

  for (s in 1:nSite) {
    u_site_tr[s] ~ dnorm(0, tau_site_tr)
  }
  tau_site_tr <- pow(sigma_site_tr, -2)
  sigma_site_tr ~ dunif(0, 2)


  ################################################
  # 4. RACE MODEL: race | site (LAST in ordering)
  ################################################

  for (i in 1:N) {
    race[i] ~ dcat(pi_race[ site[i], 1:nRace ])
  }

  for (s in 1:nSite) {
    pi_race[s, 1:nRace] ~ ddirch(alpha[])
  }

}
"
```

```{r}
data_list <- list(
  N      = nrow(x),
  nSite  = nlevels(x$site_id),
  nTime  = nlevels(x$time2),
  nRace  = nlevels(x$race2),

  home      = x$home_num,                          # 0/1
  age       = x$age,                               # numeric, NA allowed
  notify    = x$notify_num,                        # 0/1, NA allowed
  transport = x$transport_num,                     # 0/1, NA allowed
  had_tpa   = as.integer(x$had_tpa),
  had_thromb= as.integer(x$had_thrombectomy),
  tpa_comp  = as.integer(x$tpa_complic),
  thr_comp  = as.integer(x$thr_complic),

  gender = x$gender_num,                           # 0/1
  race   = as.integer(x$race2),                    # 1..nRace, NA allowed

  site   = as.integer(x$site_id),                  # 1..nSite
  time   = as.integer(x$time2),                    # 1..nTime

  alpha  = rep(0.5, nlevels(x$race2))              # Jeffreys prior for race
)
```

```{r}
library(rjags)

jmod <- jags.model(textConnection(model_string),
                   data = data_list,
                   n.chains = 3)

update(jmod, 2000)

samps <- coda.samples(jmod,
                      variable.names = c("beta0","beta_age","beta_time",
                                         "sigma_site_out"),
                      n.iter = 5000)

summary(samps)

```
# Trace plots

# Gelman-Rubin Diagnostic

# Effective Size Results

# Posterior Results

# Residual Plots